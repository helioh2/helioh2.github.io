; Este arquivo deve conter as definições das funções do jogo (com exceção da main).
; As definições devem incluir assinatura, propósito, protótipo e templates utilizados.
;; jogo do carrimnho        

#lang racket

(require 2htdp/image)
(require 2htdp/universe)
(require "constantes.rkt") ;importa as constantes definidas no arquivo "constantes.rkt"
(require "dados.rkt") ;importa as definições de dados definidas no arquivo "dados.rkt"
(require rackunit)

(provide (all-defined-out)) ;permite que outros arquivos importem deste

;; Numero, NUmero, NUmero, NUmero -> NUmero
;; retorna a distancia entre os dois pontos
;; (define (soma-cartesiana x y) (+ (dobro x) (dobro y))

(define (distancia-cartesiana x1 y1 x2 y2)
  (local 
    [(define (quadrado x)
       (* x x ))]
    (sqrt (+ (quadrado (-(x2 x1)) (quadrado (- y2 y1)))))))

;(check-equal? (distancia-cartesiana 3 4) 5)
;(check-= (distancia-cartesiana 5 8) 9.43 0.01)
;(check-= (distancia-cartesiana 11 11) 15.55 0.01)

;; Carro -> Carro
;; produz o próximo estado do carro
;; Mover carro no eixo x 
;(define (tock carro) carro)    ;;protótipo
(define (proximo-carro c)
  (local [
          (define proximo-x
            (+ (carro-x c) (CARRO-NA-DIREITA c)))
          (define colisao-parede-direita?
            (>= proximo-x LIMITE-DIR))
          (define colisao-parede-esquerda?
            (<= proximo-x LIMITE-ESQ))  ]
    
    (cond [colisao-parede-direita?
           (make-carro LIMITE-DIR)] 
          [colisao-parede-esquerda?
           (make-carro LIMITE-ESQ) ]
         [else 
         (make-carro proximo-x)])))
  

;;EXEMPLOS

;(check-equal? (proximo-carro (make-carro 0 10))
;              (make-carro 10 10))


;; Carro-i -> carro-i
;; Mover carro-i na dy no eixo y
;(define (proximo-carro-i ci) ci)
;!!!
(define (proximo-carro-i ci)
  (local [
          (define proximo-y 
            (+ (carro-i-y ci) (carro-i-dy ci)))
          (define colisao-parede-baixo? 
            (>= proximo-y LIMITE-BAIXO))]
          
    
    (cond [colisao-parede-baixo?
           (empty)])))
           


;; Carro -> Carro
;; Aumentar velocidade dy do caro
;(define (aumentar-carro-i-dy c) c) ;stub

(define (aumentar-carro-i-dy ci)
  (cond [(< (carro-i-dy ci) 0)
         (make-carro-i (carro-i-x ci)
                       (carro-i-y ci)
                   (- (carro-i-dy ci) AUMENTO-VELOCIDADE) )]
        [else
         (make-carro-i (carro-i-x ci)
                       (carro-i-y ci)
                   (+ (carro-i-dy ci) AUMENTO-VELOCIDADE) )]))


;; Arvore -> Arvore
;; Aumentar velocidade dy do Arvore
;(define (aumentar-arvore-dy a) a) ;stub

(define (aumentar-arvore-dy a)
  (cond [(< (arvore-dy a) 0)
         (make-arvore (arvore-x a)
                      (arvore-y a)
                   (- (arvore-dy a) AUMENTO-VELOCIDADE) )]
        [else
         (make-arvore (arvore-x a)
                       (arvore-y a)
                   (+ (arvore-dy a) AUMENTO-VELOCIDADE) )]))

;; Faixa -> Faixa
;; Aumentar velocidade dy da Faixa
;(define (aumentar-faixa-dy f) f) ;stub

(define (aumentar-faixa-dy f)
 (cond [(< (faixa-dy f) 0)
         (make-faixa (faixa-x f)
                     (faixa-y f)
                     (- (faixa-dy f) AUMENTO-VELOCIDADE) )]
        [else
         (make-faixa (faixa-x f)
                       (faixa-y f)
                       (+ (faixa-dy f) AUMENTO-VELOCIDADE) )]))


;; INICIO DA PARTE VISUAL DO JOGO (to draw)

;; Carro -> Image
;; desenha o cenario com o carro
;; !!!
;(define (desenha-jogo j)
; (desenha-carro (jogo-carro j)) ;stub
;(define (desenha-jogo) empty-image)  ;;protótipo

(define (desenha-carro c)
  (cond [(>= (carro-dx c) 0)
         CARRO]))


(check-equal? (desenha-carro (make-carro 100 100))
              CARRO)
(check-equal? (desenha-carro (make-carro 100 10))
               CARRO)


;; Carro-i -> Image
;; desenha o cenario com o carro
;; !!!
;(define (desenha-jogo j)
; (desenha-carro-i (jogo-carro-i j)) ;stub
;(define (desenha-jogo) empty-image)  ;;protótipo 



(define (desenha-carro-i ci)
  (cond [(>= (carro-i-dy ci) 0)
         CARRO-I]))

;; Arvore -> Image
;; desenha o cenario com a Arvore
;; !!!
;(define (desenha-arvore j)
; (desenha-arvore (jogo-arvore j)) ;stub
;(define (desenha-jogo) empty-image)  ;;protótipo 

(define (desenha-arvore a)
  (cond [(>= (arvore-dy a) 0)
         ARVORE]))

;; Faixa -> Image
;; desenha o cenario com a faixa
;; !!!
;(define (desenha-jogo j)
; (desenha-arvore (jogo-carro j)) ;stub
;(define (desenha-jogo) empty-image)  ;;protótipo 


(define (desenha-faixa f)
  (cond [(>= (faixa-dy f) 0)
         FAIXA]))


;; ListaDeCarros-i -> Image
;; Desenha o cenario só com os carros-i
;(define (desenha-carros-i ldcc) CENARIO)

(define (desenha-carros-i ldci)
  (cond [(empty? ldci) CENARIO]                   
        [else (place-image CARRO-I
                           (carro-i-x (first ldci))
                           (carro-i-y (first ldci))
                   (desenha-carros-i (rest ldci)))])) 


;; Carro -> Image 
;;Desenhar o estaodo atual do jogo
; (define (desenha-jogo j)
;    (desenha-carro (jogo-carro j))) ;stub

(define (desenha-jogo j)
  (cond [(jogo-acabou? j)
         IMG-GAME-OVER]
        [else
         (place-image (text
                       (string-append "Pontuacao: "
                                      (number->string (jogo-pontuacao j)))
                       20 "red") 70 20
                                 (place-image CARRO ((jogo-carro j))
                                               (carro-x (jogo-carro j))
                                               POS-Y-CARRO)
                                 (desenha-carro-i (jogo-carro-i j)))]))


;; Carro Carro-i -> Boolean
;; define se o jogo deve ser terminado quando ...
;; !!!
(define (terminou? estado) false)   ;;protótipo

(define (colisao-carro-carro-i? c ci)
  (local 
    [(define distancia
       (distancia-cartesiana
        (carro-x c) POS-Y-CARRO POS-X-CI (carro-i-y ci)))]
    (<= distancia (+ METADE-CARRO METADE-CARRO-I))))



;; Carro KeyEvent -> Carro 
;; quando tecla direita é pressionada produz carro na direita
;; quando tecla esquerda é pressionada produz carro na esquerda 

(define (trata-tecla-carro c ke)
  (cond [(key=? ke "left") 
         (make-carro (carro-x c) (- carro-x 2))]
        [(key=? ke "right") 
         (make-carro (carro-x c) (+ carro-x 2))]
        [else c]))     


;; EstadoMundo Integer Integer MouseEvent -> EstadoMundo
;; Quando fazer ... nas posições x y no mouse produz ...   <apagar caso não precise usar>
(define (trata-mouse j x y me)
(cond [(and (mouse=? me "button-down") (jogo-acabou? j))
       JOGO-INICIAL]
      [else j]))




